# マークアップエンジニア／フロントエンドエンジニア向けステップアップワークショップ

## 第一回：「あなたのコードはどこで動いている？」

フロントエンドエンジニア・マークアップエンジニアが知るべきスキルセット分布図

---

## はじめに

普段HTMLやCSSを書いていて、こんな疑問を持ったことはないでしょうか。

- `npm install` って何をしているの？
- なぜNode.jsをインストールしないといけないの？
- webサーバーって結局なに？

この記事では、マークアップエンジニア・フロントエンドエンジニアが日常的に触っている技術が「どこで」「何によって」動いているのかを整理します。
全体像を把握することで、自分が今取り組んでいる領域を俯瞰できるようになることが今回のゴールです。

---

## コンピュータが動く3つの場所

まず、コードが動く「場所」を整理しましょう。フロントエンドエンジニア目線で役割の分けると、大きく3つあります。

### 開発マシン（自分のPC）

あなたが今使っているPCです。コードを書いて、ビルドして、テストする場所です。ここにNode.jsやVS Codeがインストールされています。

### サーバー（24時間稼働のPC）

リクエストを受けて、レスポンスを返すPCです。AWSやGCPといったクラウドサービスも、本質的には「誰かが管理している24時間稼働のPC」です。

### ユーザーの端末（PC、スマホ、タブレット）

最終的にあなたが作ったものが表示・操作される場所です。自分たちがコントロールできない環境でもあります。どんなブラウザを使っているか、どんな回線速度かはユーザー次第です。


お気づきだと思いますが、上記のPCは役割は違うものの基本的にどのようなPCでも代替可能です。
開発でLinuxのPCを使ってもいいですし、サーバーにMacを使っても構いません。ラズパイでも同じことができます。ユーザー（bot）がLinuxサーバーの場合もあります。

---

## スキルセット分布図

次に、これらの場所で「何が動いているか」を整理します。

### 横軸：コンピュータの場所

データの流れ順に並べると、開発マシン → サーバー → ユーザーの端末となります。

### 縦軸：ソフトウェアの種類

開発やWebサービスの提供に用いるソフトウェアにはいくつかの種類があります。

- **ブラウザソフトウェア**
- **Webサーバーソフトウェア**
- **ランタイムソフトウェア**
- **ランタイム上で動作するビルドツールやフレームワーク**
- **その他ネイティブアプリ**

### 分布図

| | 開発マシン（自分のPC） | サーバー（24時間稼働のPC） | ユーザーの端末 |
|---|---|---|---|
| ブラウザソフトウェア | - | - | Chrome / Safari / Firefox |
| 　└ その上で動くもの | - | - | 自作Javascriptプログラム / フレームワーク（React / Vue.js / jQuery / Three.js） |
| Webサーバーソフトウェア | - | nginx / Apache | - |
| ランタイムソフトウェア | Node.js | Node.js / PHP | - |
| 　└ その上で動くもの | Vite / webpack / Sass / PostCSS（ビルドツール） | 自作プログラム / フレームワーク（Next.js / Nuxt / Express / Hono / Laravel） | - |
| その他ネイティブアプリ | Git / VS Code | ffmpeg 等 | Electron製アプリ / iOS・Androidアプリ |

上記のマトリクスでは、「主に使われる」という意味でソフトウェアを例示していますが、開発マシンでは当然Chromeをつかいますし、Webサーバーも使います。サーバーにChromeやGitをインストールすることももちろん可能です。

マークアップエンジニアの主戦場は「ユーザーの端末 × ブラウザ」の領域です。しかし、開発マシンでビルドツールも日常的に触っています。
この全体像が見えると、各ツールの役割が理解しやすくなります。
サーバーのランタイム経由でffmpegを動かして、画像や動画を編集するなんてアイディアも自然と湧いてくるかもしれません。

---

## ビルドツールの話

### なぜそのまま配信しないのか

書いたコードをそのままユーザーに届けない理由は3つあります。

1. **ブラウザが理解できない記法がある**：Sass、JSX、TypeScriptはブラウザが直接解釈できません
2. **ファイルが多すぎると遅い**：100個のJSファイルを個別に読み込むと、その分リクエストが発生します
3. **余計なコードを削りたい**：開発中のコメントや使っていない関数は、本番には不要です

### ビルドツールがやっていること

ビルドツールは「出荷前の加工工場」だと思えばいいでしょう。主に3つのことをしています。

**変換**
- Sass → CSS
- JSX → JavaScript
- TypeScript → JavaScript

**バンドル**
- 複数のファイルを1つ（または少数）にまとめる
- `import` の依存関係を解決する

**最適化**
- minify：空白や改行を削除してファイルサイズを小さくする
- tree shaking：使われていないコードを削除する

### 代表的なビルドツール

- **Vite**：高速な開発サーバーとビルドツール。最近の主流です
- **webpack**：長年使われてきたバンドラー。設定が複雑ですが柔軟です
- **Sass / PostCSS**：CSSの変換ツールです

### npmとは

ところで、これらのビルドツールはどうやって手に入れるのでしょうか。

npmは、Node.jsに付属するパッケージマネージャーです。世界中の開発者が作ったライブラリ（パッケージ）を公開・共有・インストールできる仕組みです。

フロントエンド開発ではJavaScriptが主流となり、ビルドツールもJavaScript（Node.js）で書かれたものが多くなりました。そのため、フロントエンドエンジニアもnpmを日常的に使うようになっています。

**主な役割**

- **パッケージのインストール**：`npm install` で必要なライブラリをダウンロード
- **依存関係の管理**：`package.json` にプロジェクトで使うパッケージを記録
- **スクリプトの実行**：`npm run build` などでビルドや開発サーバー起動を実行

ViteもwebpackもSassも、すべてnpmでインストールします。`node_modules` フォルダに大量のファイルが入るのは、依存パッケージがまとめてダウンロードされるからです。

なお、yarn や pnpm など、npm互換の別のパッケージマネージャーもあります。

---

## Webサーバーとランタイムの関係

ここが混乱しやすいポイントなので、丁寧に説明します。

### Webサーバーとは

リクエストを受けて、ファイルを返すソフトウェアです。

「`https://example.com/index.html` をください」というリクエストが来たら、`index.html` を返します。それだけです。nginxやApacheが代表例です。

### ランタイムとは

プログラムを実行する環境です。

JavaScriptを実行するならNode.js、PHPを実行するならPHPランタイムが必要です。書いたコードは、ランタイムがないと動きません。

### 3つのパターン

Webサーバーとランタイムの関係には、3つのパターンがあります。

#### パターン1：静的ファイル配信

```
リクエスト → nginx → HTML/CSS/JSをそのまま返す
```

最もシンプルです。ランタイムは不要です。HTMLやCSS、ビルド済みのJavaScriptをそのまま返すだけです。

#### パターン2：PHP（Webサーバーがランタイムを呼び出す）

```
リクエスト → nginx → PHP-FPM → 実行 → レスポンス
```

nginxは自分ではPHPを実行できません。「このリクエストは `.php` ファイルへのアクセスだ」と判断したら、常駐しているPHP-FPMに処理を依頼します。

現代ではPHP-FPMという仕組みで、PHPプロセスが常駐して待機しています。nginxがリクエストを受けたらPHP-FPMに処理を依頼し、結果を受け取って返します。PHPがApacheやnginxとセットで語られるのは、PHP自身がHTTPリクエストを直接受け取れないからです。

#### パターン3：Node.js（ランタイム自体がWebサーバー）

```
リクエスト → Node.js → レスポンス
```

Node.jsは自分でHTTPリクエストを受け取れます。つまり、ランタイムとWebサーバーが一体化しています。

ExpressやHono、Next.jsはNode.jsの上で動くフレームワークです。nginxなしでもサーバーとして機能します。（本番環境ではnginxを前段に置くことが多いですが、それはまた別の話です）

### まとめると

| パターン | Webサーバー | ランタイム | 関係 |
|---|---|---|---|
| 静的配信 | nginx / Apache | なし | Webサーバーのみ |
| PHP | nginx / Apache | PHP | Webサーバーがランタイムを呼び出す |
| Node.js | Node.js自体 | Node.js | 一体化 |

---

## ブラウザとNode.jsの違い

最後に、よくある疑問について説明します。

「Node.jsもブラウザも同じJavaScriptなのに、なぜできることが違うの？」

### 比較表

| | Node.js | ブラウザ |
|---|---|---|
| ファイル読み書き | ○ | ✕ |
| ネットワーク自由にアクセス | ○ | 制限あり（CORS） |
| OS操作 | ○ | ✕ |
| DOM操作 | ✕ | ○ |
| カメラ・マイク | ✕ | ○（許可制） |

この違いには2つの理由があります。

### 理由1：サンドボックス（セキュリティ上の制限）

ブラウザは「他人が書いた信頼できないコードを実行する」環境です。悪意あるWebサイトを開いただけで、PCのファイルを削除されたり、他のサイトの情報を盗まれたりしたら困ります。だからブラウザは、JavaScriptを「サンドボックス（砂場）」の中に閉じ込めています。

ファイル読み書き、ネットワーク、OS操作の制限はこれが理由です。

### 理由2：実行環境が提供するAPI

DOM操作やカメラ・マイクへのアクセスは、ブラウザが専用のAPIを提供しているから可能となります。Node.jsにはHTMLドキュメントが存在しないので、DOM APIを提供していません。逆に、Node.jsはファイルシステムAPIを提供しています。

### つまり

- **Node.js**：ファイル操作やネットワーク通信など、システムレベルのAPIを提供
- **ブラウザ**：DOM操作やデバイスアクセスなど、Webページ向けのAPIを提供 + セキュリティ制限あり

同じ言語でも、「どこで動くか」によって、できることが変わります。これを理解しておくと、「なぜこの処理はサーバーでやるのか」「なぜこれはブラウザでできないのか」という疑問に答えられるようになります。

---

## まとめ

- コードが動く場所は3つ：開発マシン、サーバー、ユーザーの端末
- 各場所で動くソフトウェアがある：ブラウザ、Webサーバー、ランタイム
- ビルドツール、フレームワークやライブラリは、それらの「上で動くもの」
- 同じJavaScriptでも、ブラウザとNode.jsではできることが違う（サンドボックス）

マークアップエンジニアの主戦場はブラウザですが、隣の領域を知っていることで業務が円滑になり、制作のアイディアにもつながります。このワークショップでは、その全体像を少しずつ広げていきます。

---

## 次回予告

第二回：「マークアップとプログラミングの違い」

マークアップの目的とプログラミングの目的は何が違うのか。アクセシビリティやビジネスロジックの話を絡めながら整理します。
