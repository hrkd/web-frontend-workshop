# マークアップとプログラミングの違い

この記事はマークアップの話が多めです。最後にプログラミングについての話を少しします。

## HTMLの成り立ち

HTMLは1991年、CERNの研究者ティム・バーナーズ＝リーによって作られました。目的は、研究者同士が論文や文書を相互に参照できるようにすることでした。

HTMLの正式名称は **HyperText Markup Language** です。HyperTextとは「文書を超えて繋がるテキスト」という意味です。ある文書から別の文書へリンクで繋がる。ざっくり言ってしまえばこれがWebの原点です。

```html
<a href="https://example.com/research/paper.html">関連する論文はこちら</a>
```

このコードは「このテキストは、この場所にある文書へのリンクである」と宣言しているだけです。クリックしたらどう通信するか、画面をどう遷移させるかは、ブラウザが処理します。書き手は手順を一切記述していません。

HTMLの原点は、文書の構造を記述し、文書同士をリンクで繋ぐことでした。そこにプログラミング的な要素は一切ありませんでした。純粋に「宣言」だけの世界です。

## マークアップとプログラミングの違い

### マークアップとは

「マークアップ」は元々、印刷・出版業界の用語です。編集者や校正者が原稿に対して「ここは見出し」「ここは引用」と手書きで印（マーク）を付ける作業を指していました。

この概念がデジタル文書に転用され、テキストに「意味」や「構造」を示すタグを付与することを「マークアップ」と呼ぶようになりました。

つまりマークアップとは「何であるか」を宣言することです。

```html
<h1>ワークショップのご案内</h1>
<nav>
  <a href="/about">概要</a>
  <a href="/schedule">スケジュール</a>
</nav>
<main>
  <article>
    <h2>第二回の内容</h2>
    <p>マークアップとプログラミングの違いについて学びます。</p>
  </article>
</main>
```

ここにはロジックが一切ありません。「これは見出しである」「これはナビゲーションである」「これは記事である」と構造と意味を宣言しているだけです。

### プログラミングとは

「何をするか」手順を記述することです。

```javascript
const rawData = [
  { name: '田中', age: 25 },
  { name: '佐藤', age: 16 },
  { name: '鈴木', age: 32 },
];

// Memberクラス
class Member {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  get isAdult() {
    return this.age >= 18;
  }
}

// 生のデータをMemberに変換
const members = rawData.map(data => new Member(data.name, data.age));

// membersから成人のみを抽出
const adults = members.filter(member => member.isAdult);

// 成人の名前を表示
console.log(adults.map(member => member.name)); // ['田中', '鈴木']
```

ここには手順があります。生のデータを受け取って、メンバーとしてインスタンス化して、成人かどうかを判定して、成人だけを抽出する。コンピュータが実行する手順を記述しています。

### 対比

| | マークアップ | プログラミング |
|---|---|---|
| 記述するもの | **何であるか**（構造・意味） | **何をするか**（手順・振る舞い） |
| 性質 | 宣言的 | 手続き的 |

この2つは全く別のスキルです。マークアップエンジニアがフロントエンドエンジニアの領域に踏み出すとは、「手順を記述する」スキルを身につけることを意味します。

## マークアップの目的：アクセシビリティ

マークアップで「何であるか」を正しく宣言することには、大きな意味があります。ブラウザや支援技術（スクリーンリーダーなど）が、その宣言を読み取って適切に振る舞ってくれるからです。これがアクセシビリティの基盤です。

### セマンティックHTML（基本）

「セマンティック（semantic）」とは「意味の、意味に関する」という意味です。つまりセマンティックHTMLとは、「見た目」ではなく「意味」を正しく伝えるHTMLのことです。

適切なHTML要素を使うだけで、アクセシビリティの大部分はカバーできます。

```html
<!-- divで何でも作る -->
<div class="nav">
  <div class="nav-item">ホーム</div>
</div>

<!-- 意味のある要素を使う -->
<nav>
  <a href="/">ホーム</a>
</nav>
```

適切な要素を使うだけで、以下のことが起こります。

- **スクリーンリーダー** が「ナビゲーション」「リンク」と読み上げてくれる
- **検索エンジン** がページ構造を理解できる
- **キーボード操作** が自動的に効く（`<a>` や `<button>` はフォーカス可能）

HTMLの成り立ちの話に直結します。「何であるか」を正しく宣言すれば、ブラウザや支援技術が適切に振る舞ってくれるのです。

### WAI-ARIA（ウェイ・アリア）（中級）

WAI-ARIA（ウェイ・アリア／Web Accessibility Initiative – Accessible Rich Internet Applications）は、HTMLだけでは表現しきれない意味を補足するための属性です。

タブUI、アコーディオン、モーダルなど、モダンなUIはHTMLの標準要素だけでは表現できません。`<div>` で組むしかないケースがあります。しかし `<div>` には意味がありません。スクリーンリーダーに何も伝わりません。そこでARIA属性を使います。

#### ロール（role）— 「これは何か」を伝える

```html
<div role="tablist">
  <button role="tab">タブ1</button>
  <button role="tab">タブ2</button>
</div>
```

#### ステート（状態）— 「今どういう状態か」を伝える

`aria-selected`, `aria-expanded`, `aria-hidden` など。ユーザー操作で動的に変わる。

```html
<button role="tab" aria-selected="true">タブ1</button>
<button role="tab" aria-selected="false">タブ2</button>
```

#### プロパティ（属性）— 「何と関連しているか」を伝える

`aria-controls`, `aria-labelledby` など。基本的に変わらない関係性を示す。

```html
<button aria-expanded="false" aria-controls="menu">
  メニューを開く
</button>
<div id="menu">
  ...メニューの中身...
</div>
```

#### ライブリージョン — 「ここが動的に変わる」ことを伝える

`aria-live="polite"` は「今の読み上げが終わったら通知して」という意味。視覚的にはトーストで伝える情報を、スクリーンリーダーにも伝える仕組みです。

```html
<div aria-live="polite">
  カートに商品が追加されました
</div>
```

WAI-ARIAには重要な原則があります。**「ARIAの第一ルール：ARIAを使うな」** です。これは[W3Cの公式ドキュメント](https://www.w3.org/TR/using-aria/#rule1)に記載されていることで、HTML標準要素で表現できるなら、そちらを使えという意味です。`<button>` があるのに `<div role="button">` にする必要はありません。ARIAはHTMLだけでは足りないときの補助です。

### キーボード操作（応用）

マウスが使えない・使わないユーザーのために、キーボードだけで操作できるようにすることも重要です。

```html
<!-- キーボードで操作できない -->
<div class="button" onclick="doSomething()">送信</div>

<!-- Tabキーでフォーカスが当たり、Enterで実行できる -->
<button onclick="doSomething()">送信</button>
```

`<a>`, `<button>`, `<input>` などのHTML標準要素は、最初からキーボードフォーカスが効きます。`<div>` にはフォーカスが当たりません。ここでもセマンティックHTMLが基本となります。

### アクセシビリティのグラデーション

| レベル | やること | 難易度 |
|---|---|---|
| **基本** | セマンティックHTMLを正しく使う | 低（今すぐできる） |
| **中級** | WAI-ARIAでカスタムUIの意味を補足 | 中（UIパターンの知識が必要） |
| **応用** | キーボード操作・フォーカス管理 | 中〜高（JSも必要になる） |

セマンティックHTMLを正しく書くだけで、アクセシビリティの大部分はカバーできます。これはまさにマークアップの力であり、「正しく宣言する」ことの価値そのものです。

## なぜアクセシビリティの実現は難しいか

### HTMLの用途が変わった

HTMLは本来「文書の構造を宣言する」ための言語でした。しかし現在のWebはそれだけではありません。

- **ランディングページ** — 訴求・コンバージョンが目的で、文書構造ではなくビジュアルの流れで設計される
- **Webアプリ** — そもそも「文書」ではなく、操作するUIである
- **広告LP** — セクションごとに異なるトンマナ、構造より見た目のインパクト優先

HTMLが想定していた「構造のある文書」とは違うものを、HTMLで作っているのが現状です。

### デザインと構造の不一致

マークアップの構造を理解しないままデザインすると、マークアップエンジニアが実装時に矛盾を引き受けることになります。そしてその矛盾はアクセシビリティの劣化として、最終的にユーザーに影響します。

デザインツール（Figma等）にマークアップの概念がないのは事実です。しかし、チームが作っている最終成果物はHTMLです。

- Figmaはあくまでコミュニケーションツールであって、成果物ではない
- 最終的にユーザーに届く製品はHTMLとCSSという認識を持つ
- チーム全員がHTMLの制約とルールを理解しているのが理想

### 折り合いの付け方

とはいえ完璧は現実的に難しい。ではどうするか。

まず前提として、予算と時間があります。極端な話、予算がなくて1日で仕上げなければならないものは、Figmaからアートボードを書き出した1枚画像をHTMLに貼っても構わないと私は思います。明確なアクセシビリティが要件に含まれるなら、そのような予算やスケジュールにはならないはずです。

そこまで極端でなくても、実際は予算と時間とデザインの矛盾のグラデーションの中で折り合いをつけることになります。その上で、やり始めるとしたら以下から取り組みましょう。

**できるところからやる。** `<div>` で組んでいるところを適切な要素に置き換えるだけでも大きな改善です。`<nav>`, `<main>`, `<header>`, `<footer>` のランドマークを入れるだけでもスクリーンリーダーの体験は変わります。

**見出し階層はルールを決める。** 「`<h1>` はページに1つ」「見出しレベルは飛ばさない（`<h2>` の次は `<h3>`）」。デザイン上は小さい見出しでも、構造的に大きなセクションの開始なら `<h2>` を使う。見た目のサイズはCSSで調整すればよい。マークアップは意味、CSSは見た目。この分離を徹底する。

HTMLは文書のための言語ですが、今のWebは文書だけではありません。構造と見た目が一致しない場面は必ず出ます。与えられた制約の中で折り合いをつけるのがマークアップエンジニアの仕事であり、専門性です。

### アクセシビリティのテスト方法

実際に確認する方法を2つ紹介します。

#### Lighthouse（自動テスト）

Chrome DevToolsに内蔵されているツール。

1. Chrome DevToolsを開く
2. 「Lighthouse」タブを選択
3. 「Accessibility」にチェックを入れて「Analyze page load」
4. スコアと改善点が表示される

自動テストで検出できるのは全体の30〜40%と言われていますが、明らかな問題を素早く発見できます。

#### VoiceOver（手動テスト・iPhone）

実際のスクリーンリーダーで体験することで、ユーザーが受ける印象を理解できます。

**事前設定（初回のみ）**
設定 > アクセシビリティ > アクセシビリティショートカット > VoiceOver を選択

**テスト手順**
1. Safariで確認したいサイトを開く
2. サイドボタンをトリプルクリック → VoiceOverがオン
3. 1本指で左右にスワイプして要素間を移動
4. 見出しやリンクがどう読み上げられるか確認
5. サイドボタンをトリプルクリック → VoiceOverがオフ

Googleの検索結果画面なんかは非常によくできていますね。
自分のサイトを読み上げさせると、見出し構造や代替テキストの重要性が身をもって理解できます。

## プログラミングの目的：問題の分解

プログラミングとは「何をするか」手順を記述することだと説明しました。ではソフトウェアエンジニアは日々何をしているのか。それは、例えばビジネス上の大きな問題を、コードとして書ける大きさまで分解し、プログラミング言語で記述することです。

（ちなみに日本の受託開発の現場では「システムエンジニア（SE）= 設計」「プログラマー = 実装」という分業がありました。現代のWeb系企業ではこの区別はあまりなく、設計から実装まで一貫して担う「ソフトウェアエンジニア」が浸透しています。）

具体的な例で見てみましょう。

### 大きな問題

「ユーザーがイベントを予約できるようにしたい」

これだけではプログラムは書けません。大きすぎます。まず機能に分解します。

### 第1段階：機能に分解する

- イベントの一覧を表示する
- イベントの詳細を表示する
- 空き状況を確認する
- 予約する
- 決済する
- 確認メールを送信する
- 予約をキャンセルする
- リマインドを送信する

まだ1つ1つが大きいです。さらに分解します。

### 第2段階：1つの機能をさらに分解する

たとえば「予約する」だけでも、これだけの手順があります。

1. ユーザーが日時を選択する
2. その日時にまだ空きがあるか確認する
3. 空きがなければ「満席です」と伝える
4. 空きがあれば仮予約として確保する
5. ユーザー情報（名前、連絡先）を入力させる
6. 入力内容を検証する
7. 予約を確定する
8. 確認メールを送信する

### 第3段階：コードとして書ける大きさにする

さらに「その日時にまだ空きがあるか確認する」を分解すると、

1. 対象イベントの定員を取得する
2. その日時の現在の予約数を取得する
3. 予約数が定員未満なら「空きあり」を返す

ここまで来ると、1つ1つがコードとして書ける大きさになります。

```javascript
async function checkAvailability(eventId, date) {
  // 1. 対象イベントを取得する
  const event = await getEvent(eventId);

  // 2. その日時の現在の予約を取得する
  const currentReservations = await getReservationsByEventId(eventId, date);

  // 3. 予約数が対象イベントの定員未満なら「空きあり」を返す
  return currentReservations.length < event.capacity;
}

async function getEvent(eventId) {
  // DBからイベントを取得する処理
}

async function getReservationsByEventId(eventId, date) {
  // DBから予約を取得する処理
}
```

分解した3つの手順が、そのままコードになっています。プログラミングとは、こうして大きな問題を、コードとして書ける大きさまで分解して、手順として記述することです。

## まとめ

- HTMLは文書の構造を宣言するために生まれた言語である
- マークアップは「何であるか」を宣言すること。プログラミングは「何をするか」手順を記述すること。この2つは全く別のスキルである
- 正しく宣言するだけでアクセシビリティの大部分はカバーできる。それがマークアップの力である
- ただし現実には予算・時間・デザインの制約がある。その中で折り合いをつけるのがマークアップエンジニアの専門性である
- プログラミングとは大きな問題を、コードとして書ける大きさまで分解して記述すること
- マークアップエンジニアがフロントエンドエンジニアの領域に踏み出すとは、「手順を記述する」スキルを身につけること
